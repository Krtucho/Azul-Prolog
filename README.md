# Azul-Prolog

El juego se corre en la consola de prolog llamando al predicado start_game(N), donde N es la cantidad de jugadores que van a interactuar en la partida 2<=N<=4.
Pasos:
1 - Para compilar hacemos:
swipl main.pl
2 - Luego para ejecutar una partida:
start_game(N)
La simulación comienza por la creación de la bolsa del juego, utilizando el predicado dinámico bag(Color,Cantidad), en la que por cada color definido en el juego (negro, azul, amarillo, rojo, blanco) coloca 20 azulejos, lo que representa por cada color la cantidad de azulejos de ese color que hay en la bolsa.  También se crean los jugadores, en este caso están representados por un predicado dinámico players/9 donde  players(N, Puntuación_actual, R1, R2, R3, R4, R5, Muro, Descarte), todo esto en representación del tablero del jugador de numero N donde a cada jugador se le asocia un número por el cual se unificará con el predicado dinámico cada vez que se quiera obtener el tablero de este jugador, Puntuación_actual es un entero donde se guarda y actualiza la puntuación del jugador, Descarte representa en  cada turno cuantas fichas ha enviado al descarte hasta el momento, Ri con 1<=i<=5 representa el escalón i de la escalera asociada al jugador, cada Ri es una tupla de la forma (Color, Cantidad) donde se representa el color que está en esa fila de la escalera y la cantidad de azulejos puestos, donde Cantidad<=i . Por último el Muro es una matriz donde se coloca un 1 en el caso de poner un azulejo del color correspondiente en esa posición, esto se obtiene a partir del predicado find_col(color, fila, columna) que está definido para en caso de estar buscando en que columna va el color C de la Fila i, pero como tal funciona para los tres casos de buscar la columna, la fila o el color.
Fase I- Selección de Azulejos:
A continuación ya comenzaría a jugarse la primera ronda,  donde al principio de cada ronda se llenan las fábricas de forma aleatoria, por cada fábrica se escoge un número aleatorio entre 1 y la cantidad de fichas que hay en la bolsa y como la bolsa está distribuida por colores, se busca a que color pertenece la posición del número aleatorio seleccionado  y así se van añadiendo las fichas hasta que se completen las 4 necesarias.
Luego cada jugador por turnos toma fichas de las fábricas y las coloca en su escalera. Cuando va a tomar fichas de las fabricas primeramente gracias al predicado dinámico plays/2 el cual asocia la fábrica, los colores que aparecen en esta fábrica y la cantidad de fichas de este color que hay, selecciona una fábrica y un color de forma aleatoria tomando la cantidad de fichas correspondientes y colocándolas en su escalera. La selección de la fila de la escalera a colocar las fichas se hace a partir de la jugada a la que se le asigne más valor, para conocer la jugada de mayor valor se utiliza el predicado better_play_player(Actual_Player,Row,Discard_Amount,Value) para por cada fila ir guardando la actualización en este de cuál es la que tiene mayor valor hasta el momento. El valor de una jugada está definido como –descarte y se aumenta en 2 en caso de que se complete la fila de la escalera, por lo que la estrategia del jugador es random minimizando la cantidad de descartes por jugada.  Si en un turno el jugador descarta fichas se actualiza su contador de descartes adicionando estos nuevos y además estas fichas van directo al cementerio.
En la ronda 1 el primer jugador en jugar es el jugador 1 y durante el desarrollo de la ronda (y en todas las demás) cuando un jugador sea el primero en tomar fichas del centro, en este caso la fábrica 0, el predicado dinámico first_player(N) se actualiza con N=número de este jugador  y ese será el primero en jugar la siguiente ronda, además se le agrega 1 a su valor de descarte como simulación de que la ficha 1 va a su descarte.
 Fase II- Revestir el Muro:
Cuando ya los jugadores por turnos han tomado todos los azulejos tanto de las fábricas como del centro se procede a pasar por cada fila que hayan completado de su escalera una ficha a su lugar correspondiente en el muro y se descartan las demás del mismo color al cementerio, en este momento se calcula la puntuación a añadir teniendo en cuenta las reglas del juego y cuando ya se pasó por todas las filas de la escalera se pasa a restar puntos en dependencia de los descartes que haya hecho cada jugador en este turno, para saber cuántos puntos restar se utiliza el predicado get_negative_score(N, P) donde por cada N (cantidad de descartes del jugador), se asocia a la cantidad de puntos que pierde.
Para el cálculo de la puntuación se utilizan 1 predicado dinámico temp_score/1 que tendrá como valor la puntuación actual que se está calculando, 2 predicados dinámicos temp_bool_H/1 y temp_bool_V/1 que nos permitirán conocer si la última ficha colocada, con la cual se le está calculando la puntuación que añadirá al jugador luego de añadir la misma al muro contiene alguna ficha adyacente horizontal y verticalmente respectivamente. El algoritmo para calcular la puntuación es irnos moviendo en las 4 direcciones (Arriba, Abajo, Derecha e Izquierda) a partir de la posición de la ficha colocada en el muro.
Fase III: Mantenimiento 
Aquí primeramente se comprueba que la bolsa cuente con suficientes azulejos para jugar la siguiente ronda, si no es el caso se rellena la bolsa con los azulejos que están en el cementerio cementery(Color,Cant), predicado que funciona igual a la bolsa, y si aún no alcanzan los azulejos para jugar la siguiente partida entonces se va al final de la partida.
También se comprueba que ningún jugador haya completado una fila de su Muro, en caso afirmativo también se va al fin de la partida. 
 
 Fin de la Partida
En caso de que en la fase de mantenimiento se llegue a que la partida se ha acabado por cada jugador se busca la cantidad de filas, columnas y colores que completo en su muro y por cada uno completado se adicionan a su puntaje los puntaje 2,7,10 puntos respectivamente y luego se da el resultado del juego donde se dice la puntuación de cada jugador y cuál es el ganador, o sea el de mayor puntaje. Esto se realiza llamando al predicado calculate_row_col_diag_score(W, S), donde W será la matriz del muro y S será la puntuación que obtendrá el jugador luego de buscar cada fila, columna o color que haya sido rellenado.
